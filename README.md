## PR Reviewer Assignment Service (Avito Backend Trainee Autumn 2025)

Микросервис назначает ревьюверов на Pull Request’ы и управляет командами/активностью пользователей. API документировано
в `openapi.yml`.

### Запуск локально

1. Запуск через `docker-compose up --build` поднимет Postgres, применит миграции и стартует сервис c заранее заданным
   `POSTGRES_DSN`.
2. При отдельном запуске бинаря нужно вручную задать
   `POSTGRES_DSN=postgres://user:pass@host:5432/dbname?sslmode=disable` и применить миграции из `migrations/`.
3. Сервис слушает `:8080`. Проверка: `curl http://localhost:8080/health`.

### Тесты

```
go test ./...
```

### Ключевые решения

- Назначение ревьюверов происходит в транзакции, кандидаты выбираются случайно из активных коллег автора (создание) или
  из команды заменяемого ревьювера (переназначение).
- После merge PR возвращает полный список ревьюверов, изменение состава запрещено.
- Хендлеры покрыты unit‑тестами, usecase‑слой имеет собственные тесты с заглушками репозиториев.

Сервис реализован в духе «чистой архитектуры»: слой API (DTO/handlers) изолирован от бизнес‑логики (usecase), а работа с
данными инкапсулирована в пакете `internal/repository/postgres`. Транзакции оформлены через `domain.TxManager`, что
упрощает тестирование и замену хранилища.

### Нагрузочное тестирование

- Скрипт `scripts/load.js` моделирует одновременные сценарии создания PR, переназначения/merge и чтения списков ревью.
- Перед запуском поднять сервис через `docker-compose up --build`.
- Запустить нагрузку командой `k6 run -e BASE_URL=http://localhost:8080 scripts/load.js`.

**Результаты (k6, локальный запуск, 2 минуты нагрузки):**

***2021 Apple MacBook Pro M1-Pro 16-inch, 16 GB RAM***

- Всего запросов: 3512 (≈29 RPS).
- Ошибки: 0.02% (1 из 3512), все проверки состояний (create/reassign/merge/getReview) прошли.
- Время ответа: p95 = 15.97 мс (порог <200 мс), p90 = 13.82 мс, среднее = 7.71 мс.
- Утилизация VU: до 35 виртуальных пользователей, сценарии create/reassign/getReview выполнялись параллельно.

### Вопросы, возникшие при решении задания

- Через `/team/add` команда создается, но добавить новых пользователей в команду с существующим именем не получится. Я
  выбрал такой подход, так как это требовало меньше логики, и не противоречило условию. Интересно, как все-таки это
  задумывалось на самом деле?
- В данной версии сервиса я реализовал выбор возможных ревьюверов рандомно, учитывая условия. Изначально было не
  понятно, по какому принципу стоит выбирать их (хотелось сделать, например, исходя из нагрузки каждого из них).
- В изначальной версии сервиса я решил все транзакции делать в адаптере postgres (то есть на выходе был, например, метод
  CreateWithReviewers, который в транзакции создавал PR и автоматически назначал ревьюверов). Потом я решил еще раз
  прочитать про чистую архитектуру и посмотреть несколько реализаций, что привело в итоге к управлению транзакциями из
  юзкейса. Хотел бы услышать мнение проверяющих об этом.
- Тесты запускаются отдельно через go test, но была идея запускать их автоматически через Makefile (или .sh скрипт)
